% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/2-compute-scores.R
\name{computeSigScores}
\alias{computeSigScores}
\title{Compute the Summary Scores}
\usage{
computeSigScores(
  x,
  i = NULL,
  na.rm = TRUE,
  scores = c("mean", "trimmedMean", "weightedMean", "median", "mode", "midrange",
    "midhinge", "trimean", "briskow", "reviewedBriskow", "IQM", "weightedSum", "ssGSEA",
    "gsva", "plage", "zscore"),
  sampling = c("none", "permutation", "bootstrap"),
  n.repeat = 10L,
  cores = 1L,
  args = NULL
)
}
\arguments{
\item{x}{numerical matrix, features-by-samples}

\item{i}{(optional) numerical vector giving the rows
in \code{x} or character vector matching the row
names in \code{x}
If \code{missing} or \code{i = NULL}, all the rows
in \code{x} are considered for the computation of
the score}

\item{na.rm}{logical, whether to remove \code{NA}
values before computation}

\item{scores}{character vector, indicating the
summary score(s) to compute}

\item{sampling}{character string, indicating whether
to compute the scores using the provided data
(\code{sampling = "none"}, default) or whether
to sample the data.

Three options are available:
\describe{
\item{\code{none}}{use \code{x} as it is}
\item{\code{permutation}}{random sampling without replacement}
\item{\code{bootstrap}}{random sampling with replacement}
}}

\item{n.repeat}{integer, number of repeated samples
to generate}

\item{cores}{number of cores to use for parallel execution.}

\item{args}{named list, where the names must match the
\code{scores}. Each element in the list is another list
containing the arguments to pass to the function used
for computing the named score. For example,
\code{args = list(trimmedMean = list(trim = 0.4))}
indicates to use \code{trim = 0.4} when computing the
trimmed mean score}
}
\value{
A data frame containing the computed
score(s) for each sample. Each row corresponds to
a different sample.

If \code{sampling = "random"} or \code{sampling = "bootstrap"},
the data frame contains a column with the run information.

The two columns containing the run/sample information are:

\describe{
\item{sampleID}{the name of the sample}
\item{run}{integer indicating in which run -
out of the \code{n.repeat} - was computed the score}
}
}
\description{
This function computes summary
score(s) of the signature \code{i} in input
considering each column vector in the input matrix
\code{x}.

A parallel execution to speed up the computation
on a multi-core machine can be run by setting
the argument \code{cores} with a number greater
than \code{1}.
}
\examples{
\dontrun{
#set seed for reproducibility
set.seed(seed = 5381L)

#Define row/col size
nr = 20
nc = 10

#Create input matrix
x = matrix(
 data = stats::runif(n = nr*nc, min = 0, max = 1000),
 nrow = nr,
 ncol = nc,
 dimnames = list(
   paste0("g",seq(nr)),
   paste0("S",seq(nc))
 )
)

#Compute all scores
computeSigScores(
 x = x,
 i = rownames(x)[1:10]
)

#Compute one score
computeSigScores(
 x = x,
 i = rownames(x)[1:10],
 scores = 'mean'
)

#Compute one score passing an argument
computeSigScores(
 x = x,
 i = rownames(x)[1:10],
 scores = 'trimmedMean',
 args = list(trimmedMean = list(trim = 0.2))
)

#Compute scores with permutation
computeSigScores(
 x        = x,
 i        = rownames(x)[1:10],
 sampling = "permutation",
 n.repeat = 10
)

#Compute scores with bootstrap
computeSigScores(
 x        = x,
 i        = rownames(x)[1:10],
 sampling = "bootstrap",
 n.repeat = 10
)
}

}
\seealso{
\code{\link{getAvailableScores}},
\code{\link{meanScores}},
\code{\link{trimmedMeanScores}},
\code{\link{weightedMeanScores}},
\code{\link{interquartileMeanScores}},
\code{\link{medianScores}},
\code{\link{modeScores}},
\code{\link{midrangeScores}},
\code{\link{midhingeScores}},
\code{\link{trimeanScores}},
\code{\link{briskowScores}},
\code{\link{reviewedBriskowScores}},
\code{\link{weightedSumScores}},
\code{\link{ssGseaScores}},
\code{\link{gsvaScores}},
\code{\link{plageScores}},
\code{\link{zScores}},
\code{\link{sampleData}}
}
\author{
Alessandro Barberis
}
